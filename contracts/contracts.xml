<documents>
	<document index="1">
		<source>Account.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title Account contract for managing user profiles and stats
 * @dev This contract handles user registration, profile updates, and maintains user statistics.
 */

contract Account {
    address public owner;

    // Connect this contract with trade contract address.
    address public tradeContract;

    // Connect this contract with arbitration contract address.
    address public arbitrationContract;

    struct UserBasicInfo {
        uint256 userId;
        bytes32 userEmail;
        bytes32 userChatHandle;
        bytes32 userWebsite;
        string userAvatar;
        string userRole;
    }

    struct UserStats {
        uint256 userReputationScore;
        uint256 userEndorsementsGiven;
        uint256 userEndorsementsReceived;
        uint256 userRatingsGiven;
        uint256 userRatingsReceived;
        uint256 userDisputesInitiated;
        uint256 userDisputesLost;
        uint256 userTotalTradesInitiated;
        uint256 userTotalTradesAccepted;
        uint256 userTotalTradesCompleted;
        uint256 userTotalTradeVolume;
        uint256 userAverageTradeVolume;
        uint256 userLastCompletedTradeDate;
    }

    mapping(address => UserBasicInfo) public userBasicInfo;
    mapping(address => UserStats) public userStats;
    mapping(uint256 => address) public userIdToAddress;
    uint256 public userCount;

    event UserRegistered(address indexed user, uint256 indexed userId);
    event UserProfileUpdated(address indexed user, uint256 indexed userId);
    event EndorsementGiven(address indexed endorser, address indexed endorsed);
    event EndorsementReceived(
        address indexed endorser,
        address indexed endorsed
    );
    event ReputationUpdated(address indexed user, uint256 newReputationScore);
    event DisputeInitiated(address indexed user);
    event DisputeLost(address indexed user);
    event TradeStatsUpdated(address indexed user);
    event UserRoleUpdated(
        address indexed user,
        uint256 indexed userId,
        string newRole
    );

    // TODO: add trade and arbitration contract vars to constructor?
    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(
            msg.sender == owner,
            "Only the contract owner can perform this action"
        );
        _;
    }

    modifier onlyAuthorized() {
        require(
            msg.sender == owner ||
                msg.sender == tradeContract ||
                msg.sender == arbitrationContract,
            "Only authorized contracts can perform this action"
        );
        _;
    }

    /**
     * @dev Registers a new user with basic information
     * @param _userEmail The user's email address
     * @param _userChatHandle The user's chat handle
     * @param _userWebsite The user's website
     * @param _userAvatar The user's avatar URL
     */

    function userReg(
        bytes32 _userEmail,
        bytes32 _userChatHandle,
        bytes32 _userWebsite,
        string memory _userAvatar
    ) public {
        require(
            userBasicInfo[msg.sender].userId == 0,
            "User already registered"
        );
        require(
            _userEmail != bytes32(0) && _userChatHandle != bytes32(0),
            "Email and chat handle cannot be empty"
        );

        userCount++;
        userBasicInfo[msg.sender] = UserBasicInfo(
            userCount,
            _userEmail,
            _userChatHandle,
            _userWebsite,
            _userAvatar,
            "user"
        );
        userIdToAddress[userCount] = msg.sender;

        emit UserRegistered(msg.sender, userCount);
    }

    /**
     * @dev Updates a user's profile information
     * @param _userEmail The updated user's email address
     * @param _userChatHandle The updated user's chat handle
     * @param _userWebsite The updated user's website
     * @param _userAvatar The updated user's avatar URL
     * @param _userRole The updated user's role (only admin can update)
     */

    function userUpdateProfile(
        bytes32 _userEmail,
        bytes32 _userChatHandle,
        bytes32 _userWebsite,
        string memory _userAvatar,
        string memory _userRole
    ) public {
        require(userBasicInfo[msg.sender].userId != 0, "User not registered");
        require(
            msg.sender == owner ||
                msg.sender == userIdToAddress[userBasicInfo[msg.sender].userId],
            "Only the user or admin can update the profile"
        );

        UserBasicInfo storage user = userBasicInfo[msg.sender];
        user.userEmail = _userEmail;
        user.userChatHandle = _userChatHandle;
        user.userWebsite = _userWebsite;
        user.userAvatar = _userAvatar;

        if (msg.sender == owner) {
            user.userRole = _userRole;
            emit UserRoleUpdated(msg.sender, user.userId, _userRole);
        }

        emit UserProfileUpdated(msg.sender, user.userId);
    }

    /**
     * @dev Calculates and updates a user's reputation score based on various factors
     * @param _user The address of the user
     */

    // This function should be called whenever a user's reputation needs to be updated
    // based on trade volume, active offers, number of trades, trade completion rate,
    // trade partner ratings, endorsements, and a decay function for older trades.
    function userReputationCalc(address _user) public returns (uint256) {
        UserStats storage stats = userStats[_user];

        // Calculate reputation score based on user stats
        uint256 reputationScore = 0;

        // Increase reputation based on completed trades
        reputationScore += stats.userTotalTradesCompleted * 10;

        // Increase reputation based on trade volume
        reputationScore += stats.userTotalTradeVolume / 1 ether;

        // Decrease reputation based on disputes lost
        reputationScore -= stats.userDisputesLost * 50;

        // Increase reputation based on endorsements received
        reputationScore += stats.userEndorsementsReceived * 5;

        // Update user's reputation score
        stats.userReputationScore = reputationScore;

        emit ReputationUpdated(_user, reputationScore);

        return reputationScore;
    }

    /**
     * @dev Updates the number of endorsements given by a user
     * @param _endorser The address of the endorser
     * @param _endorsed The address of the endorsed user
     */

    function updateEndorsementsGiven(
        address _endorser,
        address _endorsed
    ) public onlyAuthorized {
        userStats[_endorser].userEndorsementsGiven++;
        emit EndorsementGiven(_endorser, _endorsed);
    }

    /**
     * @dev Updates the number of endorsements received by a user
     * @param _endorser The address of the endorser
     * @param _endorsed The address of the endorsed user
     */

    function updateEndorsementsReceived(
        address _endorser,
        address _endorsed
    ) public onlyAuthorized {
        userStats[_endorsed].userEndorsementsReceived++;
        emit EndorsementReceived(_endorser, _endorsed);
    }

    /**
     * @dev Updates the number of disputes initiated by a user
     * @param _user The address of the user
     */

    function updateDisputesInitiated(address _user) public onlyAuthorized {
        userStats[_user].userDisputesInitiated++;
        emit DisputeInitiated(_user);
    }

    /**
     * @dev Updates the number of disputes lost by a user
     * @param _user The address of the user
     */

    function updateDisputesLost(address _user) public onlyAuthorized {
        userStats[_user].userDisputesLost++;
        emit DisputeLost(_user);
    }

    /**
     * @dev Updates a user's trade statistics
     * @param _user The address of the user
     * @param _tradeVolume The volume of the trade
     * @param _initiated Whether the trade was initiated by the user
     * @param _accepted Whether the trade was accepted by the user
     * @param _completed Whether the trade was completed
     */

    function updateTradeStats(
        address _user,
        uint256 _tradeVolume,
        bool _initiated,
        bool _accepted,
        bool _completed
    ) public onlyAuthorized {
        require(_tradeVolume > 0, "Trade volume must be greater than 0");

        UserStats storage stats = userStats[_user];
        if (_initiated) {
            stats.userTotalTradesInitiated++;
        }
        if (_accepted) {
            stats.userTotalTradesAccepted++;
        }
        if (_completed) {
            stats.userTotalTradesCompleted++;
            stats.userTotalTradeVolume += _tradeVolume;
            stats.userAverageTradeVolume =
                stats.userTotalTradeVolume /
                stats.userTotalTradesCompleted;
            stats.userLastCompletedTradeDate = block.timestamp;
        }
        emit TradeStatsUpdated(_user);
    }

    /**
     * @dev Retrieves a user's reputation score
     * @param _user The address of the user
     * @return The user's reputation score
     */

    function getUserReputationScore(
        address _user
    ) public view returns (uint256) {
        return userStats[_user].userReputationScore;
    }

    /**
     * @dev Retrieves a user's basic information and statistics
     * @param _user The address of the user
     * @return basicInfo The user's basic information
     * @return stats The user's statistics
     */

    function getUserInfo(
        address _user
    )
        public
        view
        returns (UserBasicInfo memory basicInfo, UserStats memory stats)
    {
        basicInfo = userBasicInfo[_user];
        stats = userStats[_user];
    }
}
</document_content>
	</document>
	<document index="2">
		<source>Arbitration.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Trade.sol";
import "./Escrow.sol";
import "./Account.sol";

/**
 * @title Arbitration contract for resolving trade disputes
 * @dev This contract handles the creation and resolution of trade disputes.
 */

contract Arbitration {
    address public admin;
    Trade private tradeContract;
    Escrow private escrowContract;
    Account private accountContract;

    enum DisputeStatus {
        Pending,
        Resolved,
        Canceled
    }

    struct DisputeDetails {
        uint256 tradeId;
        DisputeStatus status;
        uint256 disputeTimestamp;
        uint256 resolveTimestamp;
        bool resolvedInFavorOfMaker;
    }

    uint256 public resolutionTimelock = 1 days; // Timelock period for dispute resolution

    uint256 public disputeCount;
    mapping(uint256 => DisputeDetails) public disputes;
    mapping(uint256 => uint256) public tradeDisputeIds;
    mapping(uint256 => string[]) public disputeEvidence;

    event DisputeCreated(uint256 indexed tradeId, uint256 disputeId);
    event DisputeResolved(
        uint256 indexed tradeId,
        uint256 disputeId,
        bool resolvedInFavorOfMaker
    );

    event DisputeResolutionInitiated(
        uint256 indexed tradeId,
        uint256 disputeId,
        uint256 resolutionTimestamp
    );
    event DisputeEvidenceSubmitted(
        uint256 indexed tradeId,
        uint256 disputeId,
        address indexed submitter,
        string evidence
    );
    event DisputeResolutionTimelockExpired(
        uint256 indexed tradeId,
        uint256 disputeId
    );
    event DisputeResolutionCanceled(uint256 indexed tradeId, uint256 disputeId);
    event ResolutionTimelockUpdated(uint256 newTimelock);

    constructor(
        address _admin,
        address _tradeContractAddress,
        address _escrowContractAddress,
        address _accountContractAddress
    ) {
        require(_admin != address(0), "Invalid admin address");
        require(
            _tradeContractAddress != address(0),
            "Invalid Trade contract address"
        );
        require(
            _escrowContractAddress != address(0),
            "Invalid Escrow contract address"
        );
        require(
            _accountContractAddress != address(0),
            "Invalid Account contract address"
        );

        admin = _admin;
        tradeContract = Trade(_tradeContractAddress);
        escrowContract = Escrow(_escrowContractAddress);
        accountContract = Account(_accountContractAddress);
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    modifier onlyTradeContract() {
        require(
            msg.sender == address(tradeContract),
            "Only Trade contract can perform this action"
        );
        _;
    }

    modifier onlyTradeParty(uint256 _tradeId) {
        (, address maker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );
        (, address taker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );
        require(
            msg.sender == maker || msg.sender == taker,
            "Only trade parties can perform this action"
        );
        _;
    }

    modifier disputeExists(uint256 _disputeId) {
        require(
            _disputeId > 0 && _disputeId <= disputeCount,
            "Dispute does not exist"
        );
        _;
    }

    modifier disputeNotResolved(uint256 _disputeId) {
        require(
            disputes[_disputeId].status == DisputeStatus.Pending,
            "Dispute is already resolved"
        );
        _;
    }

    modifier tradeExists(uint256 _tradeId) {
        require(
            tradeContract.trades(_tradeId).offerId != 0,
            "Trade does not exist"
        );
        _;
    }

    /**
     * @dev Allows a trade party to submit evidence for a dispute
     * @param _tradeId The ID of the trade
     * @param _evidence The evidence or arguments submitted by the trade party
     * @notice Only the trade parties (maker or taker) can submit evidence
     * @notice The dispute must be in pending status
     */
    function submitEvidence(
        uint256 _tradeId,
        string memory _evidence
    ) public tradeExists(_tradeId) onlyTradeParty(_tradeId) {
        uint256 disputeId = tradeDisputeIds[_tradeId];
        require(disputeId != 0, "No dispute found for the trade");
        require(
            disputes[disputeId].status == DisputeStatus.Pending,
            "Dispute is not in pending status"
        );

        disputeEvidence[disputeId].push(_evidence);
        emit DisputeEvidenceSubmitted(
            _tradeId,
            disputeId,
            msg.sender,
            _evidence
        );
    }

    /**
     * @dev Initiates the dispute resolution process with a timelock
     * @param _disputeId The ID of the dispute
     * @param _resolveInFavorOfMaker Whether the dispute is resolved in favor of the maker
     * @notice Only an admin can call this function
     * @notice The dispute must be in pending status
     */
    function initiateDisputeResolution(
        uint256 _disputeId,
        bool _resolveInFavorOfMaker
    )
        public
        onlyAdmin
        disputeExists(_disputeId)
        disputeNotResolved(_disputeId)
    {
        disputes[_disputeId].resolveTimestamp =
            block.timestamp +
            resolutionTimelock;
        disputes[_disputeId].resolvedInFavorOfMaker = _resolveInFavorOfMaker;

        emit DisputeResolutionInitiated(
            disputes[_disputeId].tradeId,
            _disputeId,
            disputes[_disputeId].resolveTimestamp
        );
    }

    /**
     * @dev Resolves a dispute after the timelock period has expired
     * @param _disputeId The ID of the dispute
     * @notice Only an admin can call this function
     * @notice The dispute must be in pending status and the timelock period must have expired
     */
    function resolveDisputeAfterTimelock(
        uint256 _disputeId
    )
        public
        onlyAdmin
        disputeExists(_disputeId)
        disputeNotResolved(_disputeId)
    {
        require(
            block.timestamp >= disputes[_disputeId].resolveTimestamp,
            "Timelock period has not expired"
        );

        uint256 tradeId = disputes[_disputeId].tradeId;
        bool resolvedInFavorOfMaker = disputes[_disputeId]
            .resolvedInFavorOfMaker;

        disputes[_disputeId].status = DisputeStatus.Resolved;

        (, address maker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            tradeId
        );
        (, address taker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            tradeId
        );

        if (resolvedInFavorOfMaker) {
            escrowContract.releaseCrypto(tradeId, payable(maker));
            tradeContract.updateTradeStatus(
                tradeId,
                Trade.TradeStatus.Finalized
            );
        } else {
            escrowContract.refundCrypto(tradeId, payable(taker));
            tradeContract.updateTradeStatus(
                tradeId,
                Trade.TradeStatus.Cancelled
            );
        }

        emit DisputeResolved(tradeId, _disputeId, resolvedInFavorOfMaker);
        emit DisputeResolutionTimelockExpired(tradeId, _disputeId);

        accountContract.updateDisputeStats(
            maker,
            taker,
            resolvedInFavorOfMaker
        );
    }

    /**
     * @dev Cancels a dispute resolution
     * @param _disputeId The ID of the dispute
     * @notice Only an admin can call this function
     * @notice The dispute must be in pending status
     */
    function cancelDisputeResolution(
        uint256 _disputeId
    )
        public
        onlyAdmin
        disputeExists(_disputeId)
        disputeNotResolved(_disputeId)
    {
        uint256 tradeId = disputes[_disputeId].tradeId;
        disputes[_disputeId].status = DisputeStatus.Canceled;

        emit DisputeResolutionCanceled(tradeId, _disputeId);
    }

    /**
     * @dev Retrieves the details of a dispute
     * @param _disputeId The ID of the dispute
     * @return tradeId The ID of the trade associated with the dispute
     * @return status The status of the dispute
     * @return disputeTimestamp The timestamp when the dispute was created
     * @return resolveTimestamp The timestamp when the dispute is set to be resolved
     * @return resolvedInFavorOfMaker Whether the dispute is resolved in favor of the maker
     */
    function getDisputeDetails(
        uint256 _disputeId
    )
        public
        view
        disputeExists(_disputeId)
        returns (
            uint256 tradeId,
            DisputeStatus status,
            uint256 disputeTimestamp,
            uint256 resolveTimestamp,
            bool resolvedInFavorOfMaker
        )
    {
        DisputeDetails memory dispute = disputes[_disputeId];
        tradeId = dispute.tradeId;
        status = dispute.status;
        disputeTimestamp = dispute.disputeTimestamp;
        resolveTimestamp = dispute.resolveTimestamp;
        resolvedInFavorOfMaker = dispute.resolvedInFavorOfMaker;
    }

    /**
     * @dev Updates the resolution timelock period
     * @param _newTimelock The new timelock period in seconds
     * @notice Only an admin can call this function
     */
    function updateResolutionTimelock(uint256 _newTimelock) public onlyAdmin {
        resolutionTimelock = _newTimelock;
        emit ResolutionTimelockUpdated(_newTimelock);
    }

    /**
     * @dev Creates a new dispute for a trade
     * @param _tradeId The ID of the trade
     * @notice Only the Trade contract can call this function
     * @notice The trade must be in disputed status
     */
    function handleDispute(
        uint256 _tradeId
    ) public onlyTradeContract tradeExists(_tradeId) {
        require(
            tradeContract.trades(_tradeId).tradeStatus ==
                Trade.TradeStatus.Disputed,
            "Trade is not in disputed status"
        );

        disputeCount++;
        disputes[disputeCount] = DisputeDetails(
            _tradeId,
            DisputeStatus.Pending,
            block.timestamp,
            0,
            false
        );
        tradeDisputeIds[_tradeId] = disputeCount;

        emit DisputeCreated(_tradeId, disputeCount);
    }

    /**
     * @dev Resolves a dispute
     * @param _disputeId The ID of the dispute
     * @param _resolveInFavorOfMaker Whether the dispute is resolved in favor of the maker
     * @notice Only an admin can call this function
     * @notice The dispute must be in pending status and not already initiated for resolution
     */
    function resolveDispute(
        uint256 _disputeId,
        bool _resolveInFavorOfMaker
    )
        public
        onlyAdmin
        disputeExists(_disputeId)
        disputeNotResolved(_disputeId)
    {
        require(
            disputes[_disputeId].resolveTimestamp == 0,
            "Dispute resolution already initiated"
        );

        uint256 tradeId = disputes[_disputeId].tradeId;
        (, address maker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            tradeId
        );
        (, address taker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            tradeId
        );

        disputes[_disputeId].status = DisputeStatus.Resolved;
        disputes[_disputeId].resolveTimestamp = block.timestamp;
        disputes[_disputeId].resolvedInFavorOfMaker = _resolveInFavorOfMaker;

        if (_resolveInFavorOfMaker) {
            escrowContract.releaseCrypto(tradeId, payable(maker));
        } else {
            escrowContract.refundCrypto(tradeId, payable(taker));
        }

        emit DisputeResolved(tradeId, _disputeId, _resolveInFavorOfMaker);
    }

    /**
     * @dev Checks if a dispute is resolved for a trade
     * @param _tradeId The ID of the trade
     * @return Whether the dispute is resolved
     */
    function isDisputeResolved(
        uint256 _tradeId
    ) public view tradeExists(_tradeId) returns (bool) {
        uint256 disputeId = tradeDisputeIds[_tradeId];
        return
            disputeId != 0 &&
            disputes[disputeId].status == DisputeStatus.Resolved;
    }

    /**
     * @dev Retrieves the outcome of a dispute for a trade
     * @param _tradeId The ID of the trade
     * @return Whether the dispute was resolved in favor of the maker
     */
    function getDisputeOutcome(
        uint256 _tradeId
    ) public view tradeExists(_tradeId) returns (bool) {
        uint256 disputeId = tradeDisputeIds[_tradeId];
        require(disputeId != 0, "No dispute found for the trade");
        return disputes[disputeId].resolvedInFavorOfMaker;
    }
}
</document_content>
	</document>
	<document index="3">
		<source>Escrow.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Trade.sol";
import "./Arbitration.sol";

import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

/**
 * @title Escrow contract for handling trade funds
 * @dev This contract manages the locking, releasing, refunding, splitting, and penalizing of funds for trades.
 */

contract Escrow is ReentrancyGuardUpgradeable {
    address public admin;
    Trade private tradeContract;
    Arbitration private arbitrationContract;

    uint256 public platformFeePercentage;
    uint256 public penaltyPercentage;

    struct EscrowDetails {
        uint256 tradeId;
        uint256 amount;
        bool isLocked;
        bool isReleased;
        bool isRefunded;
    }

    mapping(uint256 => EscrowDetails) public escrows;

    event CryptoLocked(uint256 indexed tradeId, uint256 amount);
    event CryptoReleased(uint256 indexed tradeId, uint256 amount);
    event CryptoRefunded(uint256 indexed tradeId, uint256 amount);
    event CryptoSplit(
        uint256 indexed tradeId,
        uint256 amount,
        uint256 splitAmount
    );
    event CryptoPenalized(
        uint256 indexed tradeId,
        uint256 amount,
        uint256 penaltyAmount
    );
    event PlatformFeePaid(uint256 indexed tradeId, uint256 feeAmount);
    event FeePercentagesUpdated(
        uint256 platformFeePercentage,
        uint256 penaltyPercentage
    );

    constructor(
        address _admin,
        address _tradeContractAddress,
        address _arbitrationContractAddress,
        uint256 _platformFeePercentage,
        uint256 _penaltyPercentage
    ) {
        require(_admin != address(0), "Invalid admin address");
        require(
            _tradeContractAddress != address(0),
            "Invalid Trade contract address"
        );
        require(
            _arbitrationContractAddress != address(0),
            "Invalid Arbitration contract address"
        );
        require(
            _platformFeePercentage <= 1,
            "Platform fee percentage must be between 0 and 1"
        );
        require(
            _penaltyPercentage <= 100,
            "Penalty percentage must be between 0 and 100"
        );

        admin = _admin;
        tradeContract = Trade(_tradeContractAddress);
        arbitrationContract = Arbitration(_arbitrationContractAddress);
        platformFeePercentage = _platformFeePercentage;
        penaltyPercentage = _penaltyPercentage;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only an admin can perform this action");
        _;
    }

    modifier onlyTradeContract() {
        require(
            msg.sender == address(tradeContract),
            "Only the Trade contract can perform this action"
        );
        _;
    }

    modifier onlyArbitrationContract() {
        require(
            msg.sender == address(arbitrationContract),
            "Only the Arbitration contract can perform this action"
        );
        _;
    }

    /**
     * @dev Locks the crypto for a trade
     * @param _tradeId The ID of the trade
     * @param _amount The amount of crypto to lock
     * @notice Only the Trade contract can call this function
     * @notice The crypto must not be already locked for the trade
     */

    function lockCrypto(
        uint256 _tradeId,
        uint256 _amount
    ) public onlyTradeContract {
        require(
            !escrows[_tradeId].isLocked,
            "The crypto is already locked for this trade"
        );

        escrows[_tradeId] = EscrowDetails(
            _tradeId,
            _amount,
            true,
            false,
            false
        );

        emit CryptoLocked(_tradeId, _amount);
    }

    /**
     * @dev Releases the crypto to the receiver after trade finalization or dispute resolution
     * @param _tradeId The ID of the trade
     * @param _receiver The address of the receiver
     * @notice Only the Trade contract can call this function
     * @notice The crypto must be locked for the trade
     * @notice The crypto must not be already released or refunded for the trade
     * @notice The trade must be finalized or the dispute must be resolved in favor of the maker
     */

    function releaseCrypto(
        uint256 _tradeId,
        address payable _receiver
    ) public nonReentrant onlyTradeContract {
        require(
            escrows[_tradeId].isLocked,
            "The crypto is not locked for this trade"
        );
        require(
            !escrows[_tradeId].isReleased,
            "The crypto is already released for this trade"
        );
        require(
            !escrows[_tradeId].isRefunded,
            "The crypto is already refunded for this trade"
        );

        (, , , , , , , , Trade.TradeStatus tradeStatus, , , ) = tradeContract
            .getTradeDetails(_tradeId);

        require(
            tradeStatus == Trade.TradeStatus.Finalized ||
                (arbitrationContract.isDisputeResolved(_tradeId) &&
                    arbitrationContract.getDisputeOutcome(_tradeId)),
            "Trade is not finalized or dispute is not resolved in favor of maker"
        );

        escrows[_tradeId].isReleased = true;

        uint256 feeAmount = calculatePlatformFee(_tradeId);
        uint256 releaseAmount = escrows[_tradeId].amount - feeAmount;

        _receiver.transfer(releaseAmount);

        emit CryptoReleased(_tradeId, releaseAmount);
        emit PlatformFeePaid(_tradeId, feeAmount);
    }

    /**
     * @dev Refunds the crypto to the taker if the trade is cancelled, timed out, or dispute resolved in favor of taker
     * @param _tradeId The ID of the trade
     * @notice Only the Trade contract can call this function
     * @notice The crypto must be locked for the trade
     * @notice The crypto must not be already refunded for the trade
     * @notice The trade must be cancelled, timed out, or the dispute must be resolved in favor of the taker
     */

    function refundCrypto(
        uint256 _tradeId
    ) public nonReentrant onlyTradeContract {
        require(
            escrows[_tradeId].isLocked,
            "Crypto is not locked for this trade"
        );
        require(
            !escrows[_tradeId].isRefunded,
            "Crypto is already refunded for this trade"
        );

        (, , , , , , , , Trade.TradeStatus tradeStatus, , , ) = tradeContract
            .getTradeDetails(_tradeId);
        require(
            tradeStatus == Trade.TradeStatus.Cancelled ||
                tradeStatus == Trade.TradeStatus.TimedOut ||
                (arbitrationContract.isDisputeResolved(_tradeId) &&
                    !arbitrationContract.getDisputeOutcome(_tradeId)),
            "Trade is not cancelled, timed out, or dispute is not resolved in favor of taker"
        );

        escrows[_tradeId].isRefunded = true;

        // Get the trade details
        (, address taker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );

        payable(taker).transfer(escrows[_tradeId].amount);

        emit CryptoRefunded(_tradeId, escrows[_tradeId].amount);
    }

    /**
     * @dev Splits the crypto and sends a portion to the receiver
     * @param _tradeId The ID of the trade
     * @param _splitAmount The amount of crypto to split
     * @param _receiver The address of the receiver
     * @notice Only an admin can call this function
     * @notice The crypto must be locked for the trade
     * @notice The crypto must not be already released or refunded for the trade
     * @notice The split amount must not exceed the locked amount
     */

    function splitCrypto(
        uint256 _tradeId,
        uint256 _splitAmount,
        address payable _receiver
    ) public nonReentrant onlyAdmin {
        require(
            escrows[_tradeId].isLocked,
            "Crypto is not locked for this trade"
        );
        require(
            !escrows[_tradeId].isReleased,
            "Crypto is already released for this trade"
        );
        require(
            !escrows[_tradeId].isRefunded,
            "Crypto is already refunded for this trade"
        );
        require(
            _splitAmount <= escrows[_tradeId].amount,
            "Split amount exceeds the locked amount"
        );

        uint256 remainingAmount = escrows[_tradeId].amount - _splitAmount;

        // Transfer the split amount to the receiver
        _receiver.transfer(_splitAmount);

        // Update the escrow amount
        escrows[_tradeId].amount = remainingAmount;

        emit CryptoSplit(_tradeId, escrows[_tradeId].amount, _splitAmount);
    }

    /**
     * @dev Penalizes the crypto by transferring a portion to the admin
     * @param _tradeId The ID of the trade
     * @notice Only an admin can call this function
     * @notice The crypto must be locked for the trade
     * @notice The crypto must not be already released or refunded for the trade
     */

    function penalizeCrypto(uint256 _tradeId) public nonReentrant onlyAdmin {
        require(
            escrows[_tradeId].isLocked,
            "Crypto is not locked for this trade"
        );
        require(
            !escrows[_tradeId].isReleased,
            "Crypto is already released for this trade"
        );
        require(
            !escrows[_tradeId].isRefunded,
            "Crypto is already refunded for this trade"
        );

        uint256 penaltyAmount = (escrows[_tradeId].amount * penaltyPercentage) /
            100;
        uint256 remainingAmount = escrows[_tradeId].amount - penaltyAmount;

        // Transfer the penalty amount to the admin
        payable(admin).transfer(penaltyAmount);

        // Update the escrow amount
        escrows[_tradeId].amount = remainingAmount;

        emit CryptoPenalized(_tradeId, escrows[_tradeId].amount, penaltyAmount);
    }

    /**
     * @dev Pays the platform fee by transferring the fee amount to the admin
     * @param _tradeId The ID of the trade
     * @notice Only an admin can call this function
     * @notice The crypto must be locked for the trade
     * @notice The crypto must not be already released or refunded for the trade
     */

    function payPlatformFee(uint256 _tradeId) public nonReentrant onlyAdmin {
        require(
            escrows[_tradeId].isLocked,
            "Crypto is not locked for this trade"
        );
        require(
            !escrows[_tradeId].isReleased,
            "Crypto is already released for this trade"
        );
        require(
            !escrows[_tradeId].isRefunded,
            "Crypto is already refunded for this trade"
        );

        uint256 feeAmount = calculatePlatformFee(_tradeId);
        uint256 remainingAmount = escrows[_tradeId].amount - feeAmount;

        // Transfer the fee amount to the admin
        payable(admin).transfer(feeAmount);

        // Update the escrow amount
        escrows[_tradeId].amount = remainingAmount;

        emit PlatformFeePaid(_tradeId, feeAmount);
    }

    /**
     * @dev Updates the platform fee and penalty percentages
     * @param _platformFeePercentage The new platform fee percentage
     * @param _penaltyPercentage The new penalty percentage
     * @notice Only an admin can call this function
     * @notice The platform fee percentage must be between 0 and 1
     * @notice The penalty percentage must be between 0 and 100
     */

    function updateFeePercentages(
        uint256 _platformFeePercentage,
        uint256 _penaltyPercentage
    ) public onlyAdmin {
        require(
            _platformFeePercentage <= 1,
            "Platform fee percentage must be between 0 and 1"
        );
        require(
            _penaltyPercentage <= 100,
            "Penalty percentage must be between 0 and 100"
        );

        platformFeePercentage = _platformFeePercentage;
        penaltyPercentage = _penaltyPercentage;

        emit FeePercentagesUpdated(_platformFeePercentage, _penaltyPercentage);
    }

    /**
     * @dev Withdraws the platform fees to the admin
     * @notice Only an admin can call this function
     */

    function withdrawPlatformFees() public nonReentrant onlyAdmin {
        uint256 balance = address(this).balance;
        payable(admin).transfer(balance);
    }

    /**
     * @dev Calculates the platform fee for a trade
     * @param _tradeId The ID of the trade
     * @return The platform fee amount
     */

    function calculatePlatformFee(
        uint256 _tradeId
    ) internal view returns (uint256) {
        return (escrows[_tradeId].amount * platformFeePercentage) / 100;
    }
}
</document_content>
	</document>
	<document index="4">
		<source>Offer.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title Offer contract for managing trade offers
 * @dev This contract handles offer creation, updates, and maintains offer statistics.
 */

contract Offer {
    address public owner;
    bool public paused;

    // Connect this contract with trade contract address.
    address public tradeContract;

    enum OfferStatus {
        Active,
        Paused,
        Withdrawn
    }

    struct OfferDetails {
        address offerOwner;
        uint256 offerTotalTradesAccepted;
        uint256 offerTotalTradesCompleted;
        uint256 offerDisputesInvolved;
        uint256 offerDisputesLost;
        uint256 offerAverageTradeVolume;
        uint256 offerMinTradeAmount;
        uint256 offerMaxTradeAmount;
        string offerFiatCurrency;
        OfferStatus offerStatus;
        uint256 offerCreatedTime;
        uint256 offerLastUpdatedTime;
    }

    uint256 public offerCount;

    mapping(uint256 => OfferDetails) public offers;
    mapping(address => uint256[]) public userOffers;
    mapping(uint256 => mapping(uint256 => bool)) public offerDisputeCounted;
    mapping(address => mapping(bytes32 => bool)) public offerParametersUsed;

    // event TradeContractSet(
    //     address indexed previousAddress,
    //     address indexed newAddress
    // );
    event OfferCreated(
        uint256 indexed offerId,
        address indexed offerOwner,
        uint256 minTradeAmount,
        uint256 maxTradeAmount,
        string fiatCurrency,
        OfferStatus status
    );
    event OfferUpdated(
        uint256 indexed offerId,
        uint256 minTradeAmount,
        uint256 maxTradeAmount,
        OfferStatus status
    );
    event OfferPaused(uint256 indexed offerId);
    event OfferActivated(uint256 indexed offerId);
    event OfferWithdrawn(uint256 indexed offerId);
    event OfferMinMaxTradeAmountsChanged(
        uint256 indexed offerId,
        uint256 minAmount,
        uint256 maxAmount
    );
    event OfferStatsUpdated(uint256 indexed offerId);
    event OfferTradeAccepted(uint256 indexed offerId);
    event OfferTradeCompleted(uint256 indexed offerId, uint256 tradeVolume);
    event OfferDisputeInvolved(uint256 indexed offerId, uint256 disputeId);
    event OfferDisputeLost(uint256 indexed offerId, uint256 disputeId);
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    event ContractPaused();
    event ContractUnpaused();

    constructor(address _tradeContract) {
        require(_tradeContract != address(0), "Invalid Trade contract address");
        owner = msg.sender;
        tradeContract = _tradeContract;
    }

    // Or enable owner to change it?
    // function setTradeContract(address _tradeContract) public onlyOwner {
    //     require(_tradeContract != address(0), "Invalid Trade contract address");
    //     emit TradeContractSet(tradeContract, _tradeContract);
    //     tradeContract = _tradeContract;
    // }

    modifier onlyOwner() {
        require(
            msg.sender == owner,
            "Only the contract owner can perform this action"
        );
        _;
    }

    modifier onlyTradeContract() {
        require(
            msg.sender == tradeContract,
            "Only Trade contract can perform this action"
        );
        _;
    }

    modifier offerExists(uint256 _offerId) {
        require(_offerId > 0 && _offerId <= offerCount, "Offer does not exist");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    /**
     * @dev Retrieves the list of offers created by a user
     * @param _user The address of the user
     * @return The array of offer IDs created by the user
     */

    function getUserOffers(
        address _user
    ) public view returns (uint256[] memory) {
        return userOffers[_user];
    }

    /**
     * @dev Creates a new offer
     * @param _minTradeAmount The minimum trade amount for the offer
     * @param _maxTradeAmount The maximum trade amount for the offer
     * @param _fiatCurrency The fiat currency for the offer
     */

    function offerCreate(
        uint256 _minTradeAmount,
        uint256 _maxTradeAmount,
        string memory _fiatCurrency
    ) public whenNotPaused {
        require(
            _minTradeAmount <= _maxTradeAmount,
            "Invalid trade amount range"
        );
        require(
            bytes(_fiatCurrency).length > 0,
            "Fiat currency cannot be empty"
        );

        bytes32 offerHash = keccak256(
            abi.encodePacked(
                msg.sender,
                _minTradeAmount,
                _maxTradeAmount,
                _fiatCurrency
            )
        );
        require(
            !offerParametersUsed[msg.sender][offerHash],
            "Duplicate offer parameters"
        );
        offerParametersUsed[msg.sender][offerHash] = true;

        offerCount++;
        offers[offerCount] = OfferDetails(
            msg.sender,
            0,
            0,
            0,
            0,
            0,
            _minTradeAmount,
            _maxTradeAmount,
            _fiatCurrency,
            OfferStatus.Active,
            block.timestamp,
            block.timestamp
        );

        userOffers[msg.sender].push(offerCount);
        emit OfferCreated(
            offerCount,
            msg.sender,
            _minTradeAmount,
            _maxTradeAmount,
            _fiatCurrency,
            OfferStatus.Active
        );
    }

    /**
     * @dev Updates an existing offer
     * @param _offerId The ID of the offer to update
     * @param _minTradeAmount The updated minimum trade amount for the offer
     * @param _maxTradeAmount The updated maximum trade amount for the offer
     * @param _status The updated status of the offer
     */

    function offerUpdateOffer(
        uint256 _offerId,
        uint256 _minTradeAmount,
        uint256 _maxTradeAmount,
        OfferStatus _status
    ) public offerExists(_offerId) {
        require(
            offers[_offerId].offerOwner == msg.sender,
            "Only offer owner can update the offer"
        );
        require(
            _minTradeAmount <= _maxTradeAmount,
            "Invalid trade amount range"
        );

        OfferDetails storage offer = offers[_offerId];

        if (
            offer.offerMinTradeAmount != _minTradeAmount ||
            offer.offerMaxTradeAmount != _maxTradeAmount
        ) {
            offer.offerMinTradeAmount = _minTradeAmount;
            offer.offerMaxTradeAmount = _maxTradeAmount;
            emit OfferMinMaxTradeAmountsChanged(
                _offerId,
                _minTradeAmount,
                _maxTradeAmount
            );
        }

        offer.offerLastUpdatedTime = block.timestamp;

        emit OfferUpdated(_offerId, _minTradeAmount, _maxTradeAmount, _status);

        if (offer.offerStatus != _status) {
            offer.offerStatus = _status;
            if (_status == OfferStatus.Paused) {
                emit OfferPaused(_offerId);
            } else if (_status == OfferStatus.Active) {
                emit OfferActivated(_offerId);
            } else if (_status == OfferStatus.Withdrawn) {
                emit OfferWithdrawn(_offerId);
            }
        }
    }

    /**
     * @dev Retrieves the details of an offer
     * @param _offerId The ID of the offer
     * @return The offer details
     */

    function getOfferDetails(
        uint256 _offerId
    )
        public
        view
        offerExists(_offerId)
        returns (
            address,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            string memory,
            bool,
            uint256,
            uint256
        )
    {
        OfferDetails memory offer = offers[_offerId];
        return (
            offer.offerOwner,
            offer.offerTotalTradesAccepted,
            offer.offerTotalTradesCompleted,
            offer.offerDisputesInvolved,
            offer.offerDisputesLost,
            offer.offerAverageTradeVolume,
            offer.offerMinTradeAmount,
            offer.offerMaxTradeAmount,
            offer.offerFiatCurrency,
            offer.offerStatus == OfferStatus.Active,
            offer.offerCreatedTime,
            offer.offerLastUpdatedTime
        );
    }

    /**
     * @dev Retrieves the counts of accepted, completed, disputed, and lost trades for all offers
     * @return acceptedCount The total number of accepted trades
     * @return completedCount The total number of completed trades
     * @return disputedCount The total number of disputed trades
     * @return lostCount The total number of lost trades
     */

    // Opportunity to save on gas here by storing counts separately
    function getOfferCounts()
        public
        view
        returns (uint256, uint256, uint256, uint256)
    {
        uint256 acceptedCount = 0;
        uint256 completedCount = 0;
        uint256 disputedCount = 0;
        uint256 lostCount = 0;

        for (uint256 i = 1; i <= offerCount; i++) {
            acceptedCount += offers[i].offerTotalTradesAccepted;
            completedCount += offers[i].offerTotalTradesCompleted;
            disputedCount += offers[i].offerDisputesInvolved;
            lostCount += offers[i].offerDisputesLost;
        }

        return (acceptedCount, completedCount, disputedCount, lostCount);
    }

    /**
     * @dev Updates the statistics of an offer based on trade events
     * @param _offerId The ID of the offer
     * @param _tradeVolume The trade volume
     * @param _accepted Whether the trade was accepted
     * @param _completed Whether the trade was completed
     * @param _disputed Whether the trade was disputed
     * @param _lost Whether the trade was lost
     * @param _disputeId The ID of the dispute
     */

    function updateOfferStats(
        uint256 _offerId,
        uint256 _tradeVolume,
        bool _accepted,
        bool _completed,
        bool _disputed,
        bool _lost,
        uint256 _disputeId
    ) public offerExists(_offerId) whenNotPaused onlyTradeContract {
        require(_disputeId > 0, "Invalid dispute ID");

        OfferDetails storage offer = offers[_offerId];
        bool statsUpdated = false;

        if (_accepted) {
            offer.offerTotalTradesAccepted++;
            emit OfferTradeAccepted(_offerId);
            statsUpdated = true;
        }
        if (_completed) {
            offer.offerTotalTradesCompleted++;
            emit OfferTradeCompleted(_offerId, _tradeVolume);
            if (offer.offerTotalTradesCompleted > 1) {
                offer.offerAverageTradeVolume =
                    (offer.offerAverageTradeVolume *
                        (offer.offerTotalTradesCompleted - 1) +
                        _tradeVolume) /
                    offer.offerTotalTradesCompleted;
            } else {
                offer.offerAverageTradeVolume = _tradeVolume;
            }
            statsUpdated = true;
        }
        if (_disputed && !offerDisputeCounted[_offerId][_disputeId]) {
            offer.offerDisputesInvolved++;
            offerDisputeCounted[_offerId][_disputeId] = true;
            emit OfferDisputeInvolved(_offerId, _disputeId);
            statsUpdated = true;
        }
        if (_lost && !offerDisputeCounted[_offerId][_disputeId]) {
            offer.offerDisputesLost++;
            offerDisputeCounted[_offerId][_disputeId] = true;
            emit OfferDisputeLost(_offerId, _disputeId);
            statsUpdated = true;
        }

        if (statsUpdated) {
            emit OfferStatsUpdated(_offerId);
        }
    }

    /**
     * @dev Pauses the contract, preventing offer creation and updates
     */

    function pauseContract() public onlyOwner {
        require(!paused, "Contract is already paused");
        paused = true;
        emit ContractPaused();
    }

    /**
     * @dev Unpauses the contract, allowing offer creation and updates
     */

    function unpauseContract() public onlyOwner {
        require(paused, "Contract is not paused");
        paused = false;
        emit ContractUnpaused();
    }

    /**
     * @dev Transfers ownership of the contract to a new owner
     * @param _newOwner The address of the new owner
     */

    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "Invalid new owner address");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
}
</document_content>
	</document>
	<document index="5">
		<source>Rating.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Trade.sol";
import "./Offer.sol";
import "./Account.sol";

/**
 * @title Rating contract for managing trade ratings
 * @dev This contract handles the rating of trades by trade parties.
 */
contract Rating {
    Trade private tradeContract;
    Offer private offerContract;
    Account private accountContract;

    struct RatingDetails {
        uint256 tradeId;
        uint256 offerId;
        address raterId;
        address rateeId;
        uint256 rateStars;
        string rateString;
        uint256 rateTimestamp;
    }

    uint256 public ratingCount;
    mapping(uint256 => RatingDetails) public ratings;
    mapping(uint256 => mapping(address => bool)) public tradeRatings;

    event TradeRated(
        uint256 indexed tradeId,
        uint256 indexed offerId,
        address indexed raterId,
        address rateeId,
        uint256 rateStars,
        string rateString
    );

    event UserReputationUpdated(address indexed user, uint256 newReputation);

    constructor(
        address _tradeContractAddress,
        address _offerContractAddress,
        address _accountContractAddress
    ) {
        require(
            _tradeContractAddress != address(0),
            "Invalid Trade contract address"
        );
        require(
            _offerContractAddress != address(0),
            "Invalid Offer contract address"
        );
        require(
            _accountContractAddress != address(0),
            "Invalid Account contract address"
        );

        tradeContract = Trade(_tradeContractAddress);
        offerContract = Offer(_offerContractAddress);
        accountContract = Account(_accountContractAddress);
    }

    modifier onlyTradeParty(uint256 _tradeId) {
        (, address maker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );
        (, address taker, , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );
        require(
            msg.sender == maker || msg.sender == taker,
            "Only trade parties can perform this action"
        );
        _;
    }

    modifier tradeExists(uint256 _tradeId) {
        (uint256 offerId, , , , , , , , , , , ) = tradeContract.getTradeDetails(
            _tradeId
        );
        require(offerId != 0, "Trade does not exist");
        _;
    }

    modifier tradeFinalized(uint256 _tradeId) {
        (, , , , , , , , Trade.TradeStatus tradeStatus, , , ) = tradeContract
            .getTradeDetails(_tradeId);
        require(
            tradeStatus == Trade.TradeStatus.Finalized,
            "Trade is not in finalized status"
        );
        _;
    }

    modifier notAlreadyRated(uint256 _tradeId) {
        require(
            !tradeRatings[_tradeId][msg.sender],
            "Trade has already been rated by the user"
        );
        _;
    }

    /**
     * @dev Rates a trade
     * @param _tradeId The ID of the trade
     * @param _rateStars The rating stars given (1-5)
     * @param _rateString The rating comment
     * @notice Only the trade parties (maker or taker) can rate the trade
     * @notice The trade must be in finalized status
     * @notice The user can only rate a trade once
     */
    function rateTrade(
        uint256 _tradeId,
        uint256 _rateStars,
        string memory _rateString
    )
        public
        tradeExists(_tradeId)
        tradeFinalized(_tradeId)
        onlyTradeParty(_tradeId)
        notAlreadyRated(_tradeId)
    {
        require(
            _rateStars >= 1 && _rateStars <= 5,
            "Rating stars must be between 1 and 5"
        );
        require(
            bytes(_rateString).length <= 280,
            "Rating string must not exceed 280 bytes"
        );

        (uint256 offerId, address taker, , , , , , , , , , ) = tradeContract
            .getTradeDetails(_tradeId);
        address rateeId;
        if (msg.sender == taker) {
            (address offerOwner, , , , , , , , , , , ) = offerContract
                .getOfferDetails(offerId);
            rateeId = offerOwner;
        } else {
            rateeId = taker;
        }

        ratingCount++;
        ratings[ratingCount] = RatingDetails(
            _tradeId,
            offerId,
            msg.sender,
            rateeId,
            _rateStars,
            _rateString,
            block.timestamp
        );
        tradeRatings[_tradeId][msg.sender] = true;

        emit TradeRated(
            _tradeId,
            offerId,
            msg.sender,
            rateeId,
            _rateStars,
            _rateString
        );

        // Update user reputation in the Account contract
        uint256 newReputation = accountContract.userReputationCalc(rateeId);
        emit UserReputationUpdated(rateeId, newReputation);
    }
}
</document_content>
	</document>
	<document index="6">
		<source>Reputation.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Account.sol";

/**
 * @title Reputation contract for calculating user reputation scores
 * @dev This contract calculates user reputation scores based on various factors.
 */

contract Reputation {
    Account private accountContract;

    uint256 private constant REPUTATION_SCALE = 100;
    uint256 private constant TRADE_VOLUME_WEIGHT = 30;
    uint256 private constant ACTIVE_OFFERS_WEIGHT = 20;
    uint256 private constant TRADE_COUNT_WEIGHT = 20;
    uint256 private constant COMPLETION_RATE_WEIGHT = 15;
    uint256 private constant RATING_WEIGHT = 10;
    uint256 private constant ENDORSEMENT_WEIGHT = 5;

    constructor(address _accountContractAddress) {
        require(
            _accountContractAddress != address(0),
            "Invalid Account contract address"
        );
        accountContract = Account(_accountContractAddress);
    }

    /**
     * @dev Calculates the reputation score for a user
     * @param _user The address of the user
     * @return The calculated reputation score
     */

    function calculateReputation(address _user) public view returns (uint256) {
        (, Account.UserStats memory stats) = accountContract.getUserInfo(_user);

        uint256 tradeVolumeScore = stats.userTotalTradeVolume *
            TRADE_VOLUME_WEIGHT;
        uint256 activeOffersScore = stats.userTotalTradesInitiated *
            ACTIVE_OFFERS_WEIGHT;
        uint256 tradeCountScore = stats.userTotalTradesCompleted *
            TRADE_COUNT_WEIGHT;

        uint256 completionRate = (stats.userTotalTradesCompleted * 100) /
            (
                stats.userTotalTradesAccepted == 0
                    ? 1
                    : stats.userTotalTradesAccepted
            );
        uint256 completionRateScore = (completionRate *
            COMPLETION_RATE_WEIGHT) / 100;

        uint256 ratingScore = stats.userReputationScore * RATING_WEIGHT;
        uint256 endorsementScore = stats.userEndorsementsReceived *
            ENDORSEMENT_WEIGHT;

        uint256 totalScore = tradeVolumeScore +
            activeOffersScore +
            tradeCountScore +
            completionRateScore +
            ratingScore +
            endorsementScore;

        uint256 reputationScore = totalScore / REPUTATION_SCALE;

        // Apply decay factor to reduce the importance of older trades
        uint256 decayFactor = calculateDecayFactor(
            stats.userLastCompletedTradeDate
        );
        reputationScore = (reputationScore * decayFactor) / 100;

        return reputationScore;
    }

    /**
     * @dev Calculates the decay factor based on the time since the last completed trade
     * @param _lastTradeTimestamp The timestamp of the last completed trade
     * @return The calculated decay factor
     */

    function calculateDecayFactor(
        uint256 _lastTradeTimestamp
    ) private view returns (uint256) {
        if (_lastTradeTimestamp == 0) {
            return 100;
        }

        uint256 timeSinceLastTrade = block.timestamp - _lastTradeTimestamp;

        if (timeSinceLastTrade > 365 days) {
            return 50;
        } else if (timeSinceLastTrade > 180 days) {
            return 75;
        } else {
            return 100;
        }
    }
}
</document_content>
	</document>
	<document index="7">
		<source>Trade.sol</source>
		<document_content>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Offer.sol";
import "./Escrow.sol";
import "./Arbitration.sol";
import "./Rating.sol";

import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";

/**
 * @title Trade contract for managing trades between users
 * @dev This contract handles trade initiation, acceptance, finalization, cancellation, and dispute resolution.
 */

contract Trade is ReentrancyGuardUpgradeable {
    Offer private offerContract;
    Escrow private escrowContract;
    Arbitration private arbitrationContract;
    Rating private ratingContract;

    address public owner;

    enum TradeStatus {
        Initiated,
        Accepted,
        FiatPaid,
        Finalized,
        Cancelled,
        Disputed,
        TimedOut,
        Refunded
    }

    struct TradeDetails {
        uint256 offerId;
        address taker;
        uint256 tradeAmountFiat;
        uint256 tradeAmountCrypto;
        string tradeFiatCurrency;
        string tradeCryptoCurrency;
        uint256 blocksTillTimeout;
        string tradeCancelationReason;
        TradeStatus tradeStatus;
        uint256 tradeInitiatedTime;
        uint256 tradeFinalizedTime;
        uint256 tradeFee;
    }

    uint256 public tradeCount;
    mapping(uint256 => TradeDetails) public trades;
    mapping(TradeStatus => mapping(TradeStatus => bool))
        public validTransitions;
    mapping(address => bool) public admins;
    mapping(uint256 => mapping(address => bool)) public tradeRatings;

    constructor(
        address _offerContractAddress,
        address _escrowContractAddress,
        address _arbitrationContractAddress,
        address _ratingContractAddress
    ) {
        offerContract = Offer(_offerContractAddress);
        escrowContract = Escrow(_escrowContractAddress);
        arbitrationContract = Arbitration(_arbitrationContractAddress);
        ratingContract = Rating(_ratingContractAddress);

        owner = msg.sender;

        // Initialize valid trade status transitions
        validTransitions[TradeStatus.Initiated][TradeStatus.Accepted] = true;

        // allow trade to be cancelled when in initiated status
        validTransitions[TradeStatus.Initiated][TradeStatus.Cancelled] = true;

        validTransitions[TradeStatus.Accepted][TradeStatus.FiatPaid] = true;
        validTransitions[TradeStatus.Accepted][TradeStatus.Disputed] = true;

        // allow trade to be finalized from disputed status
        validTransitions[TradeStatus.Disputed][TradeStatus.Finalized] = true;
        // allow trade to be cancelled from disputed status
        validTransitions[TradeStatus.Disputed][TradeStatus.Cancelled] = true;

        // allow trade to be timedout from various statuses
        validTransitions[TradeStatus.Initiated][TradeStatus.TimedOut] = true;
        validTransitions[TradeStatus.Accepted][TradeStatus.TimedOut] = true;
        // validTransitions[TradeStatus.FiatPaid][TradeStatus.TimedOut] = true;

        validTransitions[TradeStatus.Accepted][TradeStatus.Cancelled] = true;
        validTransitions[TradeStatus.FiatPaid][TradeStatus.Finalized] = true;
        validTransitions[TradeStatus.FiatPaid][TradeStatus.Disputed] = true;
    }

    event TradeInitiated(
        uint256 indexed tradeId,
        uint256 indexed offerId,
        address indexed taker
    );
    event TradeAccepted(uint256 indexed tradeId);
    event CryptoLockedInEscrow(uint256 indexed tradeId, uint256 amount);
    event FiatMarkedAsPaid(uint256 indexed tradeId);
    event TradeFinalized(uint256 indexed tradeId, uint256 timestamp);
    event TradeCancelled(uint256 indexed tradeId, string reason);
    event TradeDisputed(uint256 indexed tradeId);
    event TradeTimedOut(uint256 indexed tradeId);
    event TradeRated(uint256 indexed tradeId, uint256 rating, string feedback);
    event AdminSet(address indexed admin, bool isAdmin);

    modifier onlyOwner() {
        require(
            msg.sender == owner,
            "Only the contract owner can perform this action"
        );
        _;
    }

    modifier onlyAdmin() {
        require(admins[msg.sender], "Only admin can perform this action");
        _;
    }

    modifier onlyTradeParty(uint256 _tradeId) {
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            trades[_tradeId].taker == msg.sender || offerOwner == msg.sender,
            "Only trade parties can perform this action"
        );
        _;
    }

    modifier tradeExists(uint256 _tradeId) {
        require(_tradeId > 0 && _tradeId <= tradeCount, "Trade does not exist");
        _;
    }

    /**
     * @dev Sets the initial admin addresses
     * @param _admins An array of addresses to be set as admins
     */

    function setInitialAdmins(address[] memory _admins) public onlyOwner {
        require(admins[owner] == false, "Initial admins can only be set once");

        for (uint256 i = 0; i < _admins.length; i++) {
            admins[_admins[i]] = true;
            emit AdminSet(_admins[i], true);
        }

        admins[owner] = true;
        emit AdminSet(owner, true);
    }

    /**
     * @dev Sets or removes an admin
     * @param _admin The address to be set or removed as an admin
     * @param _isAdmin A boolean indicating whether to set or remove the admin
     */

    function setAdmin(address _admin, bool _isAdmin) public onlyAdmin {
        admins[_admin] = _isAdmin;
        emit AdminSet(_admin, _isAdmin);
    }

    /**
     * @dev Initiates a new trade
     * @param _offerId The ID of the offer for the trade
     * @param _tradeAmountFiat The fiat amount of the trade
     * @param _tradeAmountCrypto The crypto amount of the trade
     * @param _tradeFiatCurrency The fiat currency of the trade
     * @param _tradeCryptoCurrency The crypto currency of the trade
     * @param _blocksTillTimeout The number of blocks until the trade times out
     * @param _tradeCancelationReason The reason for trade cancellation, if applicable
     */

    function initiateTrade(
        uint256 _offerId,
        uint256 _tradeAmountFiat,
        uint256 _tradeAmountCrypto,
        string memory _tradeFiatCurrency,
        string memory _tradeCryptoCurrency,
        uint256 _blocksTillTimeout,
        string memory _tradeCancelationReason
    ) public {
        (
            ,
            ,
            ,
            ,
            ,
            ,
            uint256 offerMinTradeAmount,
            uint256 offerMaxTradeAmount,
            ,
            bool offerStatus,
            ,

        ) = offerContract.getOfferDetails(_offerId);
        require(offerStatus, "Offer is not active");
        require(
            _tradeAmountFiat >= offerMinTradeAmount &&
                _tradeAmountFiat <= offerMaxTradeAmount,
            "Trade amount is outside the offer range"
        );

        tradeCount++;
        trades[tradeCount] = TradeDetails(
            _offerId,
            msg.sender,
            _tradeAmountFiat,
            _tradeAmountCrypto,
            _tradeFiatCurrency,
            _tradeCryptoCurrency,
            _blocksTillTimeout,
            _tradeCancelationReason,
            TradeStatus.Initiated,
            block.timestamp,
            0,
            0
        );

        emit TradeInitiated(tradeCount, _offerId, msg.sender);
    }

    /**
     * @dev Updates the trade status
     * @param _tradeId The ID of the trade
     * @param _newStatus The new status of the trade
     */

    function _updateTradeStatus(
        uint256 _tradeId,
        TradeStatus _newStatus
    ) private {
        require(
            validTransitions[trades[_tradeId].tradeStatus][_newStatus],
            "Invalid trade status transition"
        );
        trades[_tradeId].tradeStatus = _newStatus;
    }

    /**
     * @dev Accepts a trade
     * @param _tradeId The ID of the trade to accept
     */

    function acceptTrade(uint256 _tradeId) public tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Initiated,
            "Trade is not in initiated status"
        );
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            offerOwner == msg.sender,
            "Only offer owner can accept the trade"
        );

        _updateTradeStatus(_tradeId, TradeStatus.Accepted);
        emit TradeAccepted(_tradeId);
    }

    /**
     * @dev Locks the crypto amount in escrow for a trade
     * @param _tradeId The ID of the trade
     */

    function lockCryptoInEscrow(
        uint256 _tradeId
    ) public nonReentrant tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Accepted,
            "Trade is not in accepted status"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Finalized,
            "Trade has already been finalized"
        );
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            offerOwner == msg.sender,
            "Only offer owner can lock crypto in escrow"
        );

        // Call the Escrow contract to lock the crypto
        escrowContract.lockCrypto(_tradeId, trades[_tradeId].tradeAmountCrypto);
        emit CryptoLockedInEscrow(_tradeId, trades[_tradeId].tradeAmountCrypto);
    }

    /**
     * @dev Marks the fiat as paid for a trade
     * @param _tradeId The ID of the trade
     */

    function tradeMarkFiatPaid(uint256 _tradeId) public tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Accepted,
            "Trade is not in accepted status"
        );
        require(
            trades[_tradeId].taker == msg.sender,
            "Only trade taker can mark fiat as paid"
        );

        _updateTradeStatus(_tradeId, TradeStatus.FiatPaid);
        emit FiatMarkedAsPaid(_tradeId);
    }

    /**
     * @dev Finalizes a trade
     * @param _tradeId The ID of the trade to finalize
     */

    function finalizeTrade(
        uint256 _tradeId
    ) public nonReentrant tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.FiatPaid ||
                (trades[_tradeId].tradeStatus == TradeStatus.Disputed &&
                    admins[msg.sender]),
            "Trade is not in a finalizable state or caller is not an admin"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Cancelled &&
                trades[_tradeId].tradeStatus != TradeStatus.TimedOut,
            "Trade cannot be finalized if it is cancelled or timed out"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Finalized,
            "Trade has already been finalized"
        );
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            offerOwner == msg.sender || admins[msg.sender],
            "Only offer owner or admin can finalize the trade"
        );

        _updateTradeStatus(_tradeId, TradeStatus.Finalized);
        trades[_tradeId].tradeFinalizedTime = block.timestamp;

        // Call the Escrow contract to release the crypto to the taker
        escrowContract.releaseCrypto(_tradeId, payable(trades[_tradeId].taker));
        emit TradeFinalized(_tradeId, block.timestamp);
    }

    /**
     * @dev Cancels a trade
     * @param _tradeId The ID of the trade to cancel
     */

    function cancelTrade(
        uint256 _tradeId
    ) public nonReentrant tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Initiated ||
                trades[_tradeId].tradeStatus == TradeStatus.Accepted,
            "Trade cannot be cancelled at this stage"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Disputed,
            "Trade cannot be cancelled if it is already disputed"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Finalized,
            "Trade has already been finalized"
        );
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            trades[_tradeId].taker == msg.sender || offerOwner == msg.sender,
            "Only trade parties can dispute the trade"
        );

        _updateTradeStatus(_tradeId, TradeStatus.Cancelled);

        // Call the Escrow contract to refund the crypto if it was locked
        if (trades[_tradeId].tradeStatus == TradeStatus.Accepted) {
            escrowContract.refundCrypto(_tradeId);
        }

        emit TradeCancelled(_tradeId, trades[_tradeId].tradeCancelationReason);
    }

    /**
     * @dev Disputes a trade
     * @param _tradeId The ID of the trade to dispute
     */

    function disputeTrade(
        uint256 _tradeId
    ) public nonReentrant tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Accepted ||
                trades[_tradeId].tradeStatus == TradeStatus.FiatPaid,
            "Trade cannot be disputed at this stage"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Disputed,
            "Trade is already disputed"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.Finalized,
            "Trade has already been finalized"
        );
        (address offerOwner, , , , , , , , , , , ) = offerContract
            .getOfferDetails(trades[_tradeId].offerId);
        require(
            trades[_tradeId].taker == msg.sender || offerOwner == msg.sender,
            "Only trade parties can dispute the trade"
        );

        _updateTradeStatus(_tradeId, TradeStatus.Disputed);

        // Call the Arbitration contract to handle the dispute
        arbitrationContract.handleDispute(_tradeId);
        emit TradeDisputed(_tradeId);
    }

    /**
     * @dev Times out a trade
     * @param _tradeId The ID of the trade to time out
     */

    function timeoutTrade(uint256 _tradeId) public tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Initiated ||
                trades[_tradeId].tradeStatus == TradeStatus.Accepted ||
                trades[_tradeId].tradeStatus == TradeStatus.FiatPaid,
            "Trade cannot be timed out at this stage"
        );
        require(
            trades[_tradeId].tradeStatus != TradeStatus.TimedOut,
            "Trade has already been timed out"
        );
        require(
            block.timestamp >=
                trades[_tradeId].tradeInitiatedTime +
                    trades[_tradeId].blocksTillTimeout,
            "Trade timeout period has not passed"
        );

        _updateTradeStatus(_tradeId, TradeStatus.TimedOut);
        emit TradeTimedOut(_tradeId);

        // Call the Escrow contract to refund the crypto if it was locked
        if (trades[_tradeId].tradeStatus == TradeStatus.Accepted) {
            escrowContract.refundCrypto(_tradeId);
        }
    }

    /**
     * @dev Refunds a trade
     * @param _tradeId The ID of the trade to refund
     */

    function refundTrade(
        uint256 _tradeId
    ) public tradeExists(_tradeId) nonReentrant {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Cancelled ||
                trades[_tradeId].tradeStatus == TradeStatus.TimedOut ||
                trades[_tradeId].tradeStatus == TradeStatus.Disputed,
            "Trade cannot be refunded at this stage"
        );
        require(
            msg.sender == address(escrowContract),
            "Only Escrow contract can call refund function"
        );

        // TODO: decide what to do about refunds and where that happens.
        // Refund logic handled by the Escrow contract
        // _updateTradeStatus(_tradeId, TradeStatus.Refunded);
        // emit TradeRefunded(_tradeId);
    }

    /**
     * @dev Allows a trade party to rate a finalized trade
     * @param _tradeId The ID of the trade to rate
     * @param _rating The rating value (1 to 5)
     * @param _feedback The feedback string provided by the user
     * @notice Only trade parties can rate a trade
     * @notice Trade must be in finalized status
     * @notice Rating value must be between 1 and 5
     * @notice User can only rate a trade once
     */

    function rateTrade(
        uint256 _tradeId,
        uint256 _rating,
        string memory _feedback
    ) public onlyTradeParty(_tradeId) tradeExists(_tradeId) {
        require(
            trades[_tradeId].tradeStatus == TradeStatus.Finalized,
            "Trade is not finalized"
        );
        require(_rating >= 1 && _rating <= 5, "Invalid rating value");
        require(
            !tradeRatings[_tradeId][msg.sender],
            "Trade has already been rated by the user"
        );

        tradeRatings[_tradeId][msg.sender] = true;

        // Call the Rating contract to record the trade rating
        ratingContract.rateTrade(_tradeId, _rating, _feedback);

        emit TradeRated(_tradeId, _rating, _feedback);
    }

    /**
     * @dev Retrieves the details of a trade
     * @param _tradeId The ID of the trade
     * @return offerId The ID of the offer associated with the trade
     * @return taker The address of the trade taker
     * @return tradeAmountFiat The fiat amount of the trade
     * @return tradeAmountCrypto The crypto amount of the trade
     * @return tradeFiatCurrency The fiat currency of the trade
     * @return tradeCryptoCurrency The crypto currency of the trade
     * @return blocksTillTimeout The number of blocks until the trade times out
     * @return tradeCancelationReason The reason for trade cancellation, if applicable
     * @return tradeStatus The current status of the trade
     * @return tradeInitiatedTime The timestamp when the trade was initiated
     * @return tradeFinalizedTime The timestamp when the trade was finalized
     * @return tradeFee The fee associated with the trade
     * @notice Trade must exist
     */

    function getTradeDetails(
        uint256 _tradeId
    )
        public
        view
        tradeExists(_tradeId)
        returns (
            uint256,
            address,
            uint256,
            uint256,
            string memory,
            string memory,
            uint256,
            string memory,
            TradeStatus,
            uint256,
            uint256,
            uint256
        )
    {
        TradeDetails memory trade = trades[_tradeId];

        return (
            trade.offerId,
            trade.taker,
            trade.tradeAmountFiat,
            trade.tradeAmountCrypto,
            trade.tradeFiatCurrency,
            trade.tradeCryptoCurrency,
            trade.blocksTillTimeout,
            trade.tradeCancelationReason,
            trade.tradeStatus,
            trade.tradeInitiatedTime,
            trade.tradeFinalizedTime,
            trade.tradeFee
        );
    }

    /**
     * @dev Retrieves the counts of trades in different statuses
     * @return initiatedCount The count of trades in initiated status
     * @return acceptedCount The count of trades in accepted status
     * @return finalizedCount The count of trades in finalized status
     * @return cancelledCount The count of trades in cancelled status
     * @return disputedCount The count of trades in disputed status
     * @return timedOutCount The count of trades in timed out status
     * @notice This function iterates through all trades to calculate the counts
     */

    // TODO: Maybe count separately to save gas later on?
    function getTradeCounts()
        public
        view
        returns (uint256, uint256, uint256, uint256, uint256, uint256)
    {
        uint256 initiatedCount = 0;
        uint256 acceptedCount = 0;
        uint256 finalizedCount = 0;
        uint256 cancelledCount = 0;
        uint256 disputedCount = 0;
        uint256 timedOutCount = 0;

        for (uint256 i = 1; i <= tradeCount; i++) {
            TradeStatus status = trades[i].tradeStatus;
            if (status == TradeStatus.Initiated) {
                initiatedCount++;
            } else if (status == TradeStatus.Accepted) {
                acceptedCount++;
            } else if (status == TradeStatus.Finalized) {
                finalizedCount++;
            } else if (status == TradeStatus.Cancelled) {
                cancelledCount++;
            } else if (status == TradeStatus.Disputed) {
                disputedCount++;
            } else if (status == TradeStatus.TimedOut) {
                timedOutCount++;
            }
        }

        return (
            initiatedCount,
            acceptedCount,
            finalizedCount,
            cancelledCount,
            disputedCount,
            timedOutCount
        );
    }
}
</document_content>
	</document>
</documents>